{"version":3,"sources":["../src/jobs/restore.ts"],"names":[],"mappings":";AAAA,wCAA8C;AAE9C,IAAI,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AAErC,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;AACzB,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAC7B,MAAM,KAAK,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;AACxC,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,EAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AAuCzD;IACE,IAAI,OAAO,GAAG,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC;SACrC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;SACrE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACvB,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC;AAED,mBAAmB,UAAU;IAC3B,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,IAAI,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,UAAU,CAAC;SACrC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;SACxE,OAAO,CAAC,IAAI,CAAC,EAAE;QACd,IAAI,GAAG,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;QAClE,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;IACnB,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,IAAI,CAAC;AACd,CAAC;AArDD,iBAAS,KAAK;IACZ,IAAI,UAAU,GAAG,gBAAgB,EAAE,CAAC;IACpC,IAAI,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;IACjD,OAAO,CAAC,GAAG,CAAC,qBAAqB,UAAU,MAAM,CAAC,CAAC;IAEnD,IAAI,EAAE,GAAG,MAAM,mBAAS,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;IAC7C,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,mBAAS,CAAC,MAAM,CAAC,CAAC;IACzC,IAAI,OAAO,GAAG,KAAK,CAAC;IACpB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACjB,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/B,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC;IACH,CAAC,CAAC,CAAA;IACF,IAAI,GAAG,OAAO,CAAC;IACf,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACpB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClB,IAAI,KAAK,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;IAElC,GAAG,CAAC,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC;QACrB,IAAI,QAAQ,GAAG,GAAG,GAAG,OAAO,CAAC;QAC7B,EAAE,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,CAAC;gBACH,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1C,IAAI,KAAK,GAAG,iBAAO,CAAC,GAAG,CAAC,CAAC;gBACzB,MAAM,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;gBAChC,OAAO,CAAC,GAAG,CAAC,WAAW,GAAG,WAAW,CAAC,CAAC;YACzC,CAAC;YAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACX,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;gBAC5B,OAAO,CAAC,GAAG,CAAC,mBAAmB,GAAG,MAAM,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBACrD,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;YAC9B,CAAC;QACH,CAAC;IACH,CAAC;IAED,MAAM,QAAQ,EAAE,CAAC;AACnB,CAAC,CAAA","file":"restore.js","sourcesContent":["import {schemas, sequelize} from \"../schemas\";\r\nimport misc from \"libs/misc\";\r\nvar sequence = require('./sequence');\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst order = ['User', 'Muscle', 'Gym'];\r\nconst dumpPath = path.join(__dirname,'..', '..', 'dump');\r\n\r\nexport = async function main() {\r\n  let folderName = getLastestFolder();\r\n  let folderPath = path.join(dumpPath, folderName);\r\n  console.log(`=== Restore from: ${folderPath} ===`);\r\n\r\n  let rs = await sequelize.sync({force: true});\r\n  let keys = Object.keys(sequelize.models);\r\n  let tmpKeys = order;\r\n  keys.forEach(key => {\r\n    if (tmpKeys.indexOf(key) == -1) {\r\n      tmpKeys.push(key);\r\n    }\r\n  })\r\n  keys = tmpKeys;\r\n  console.log('keys');\r\n  console.log(keys);\r\n  let files = readFiles(folderPath);\r\n\r\n  for (let key of keys) {\r\n    let fileName = key + '.json';\r\n    if (files[fileName]) {\r\n      try {\r\n        let records = JSON.parse(files[fileName]);\r\n        let Model = schemas[key];\r\n        await Model.bulkCreate(records);\r\n        console.log(`Import \"${key}\" success`);\r\n      } catch (e) {\r\n        console.log('::::::::::::');\r\n        console.log(`cannot restore \"${key}\": ${e.message}`);\r\n        console.log('::::::::::::');\r\n      }\r\n    }\r\n  }\r\n\r\n  await sequence();\r\n}\r\n\r\nfunction getLastestFolder() {\r\n  let folders = fs.readdirSync(dumpPath)\r\n  .filter(file => fs.lstatSync(path.join(dumpPath, file)).isDirectory())\r\n  .sort((a, b) => b > a);\r\n  return folders[0];\r\n}\r\n\r\nfunction readFiles(folderPath) {\r\n  let hash = {};\r\n  let files = fs.readdirSync(folderPath)\r\n  .filter(file => !fs.lstatSync(path.join(folderPath, file)).isDirectory())\r\n  .forEach(file => {\r\n    let txt = fs.readFileSync(path.join(folderPath, file)).toString();\r\n    hash[file] = txt;\r\n  });\r\n  return hash;\r\n}\r\n"]}